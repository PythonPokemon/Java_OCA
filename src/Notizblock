#   Methoden
-   gehören zu Klassen und Klassen zu Packeten bsp. import
-   Wenn man eine Methode schreibt muss man immer vorschreiben zu welche typen diese Methode gehört.
-   In der Praxis wird häufig eine große komplexe Methode Öffentlich gesetzt damit diese sichtbar und zugreifbar ist,
    allerdings wird diese wiederrum in viele kleine Methoden runtergebrochen und diese werden uaf Private gestellt.
-   Wenn man eigene Methoden schreibt gehen diese den statischen import methoden vor, die imports werden dann ausgegraut, um konflikte zu vermeiden.

#   Klassen
-   die man geschrieben hat, befinden sich im sogenannten Default Package (standard packet)
    wenn man keinen packet verwendet befindet sich der Java Quellcode und der Bytecode, alle in einem großen Verzeichnis
-   Bei klassen muss man immer beschreiben aus welchem packet sie kommen.

#   Der Bytecode
-   ist zu 100% Identisch, ob man den selbst schreibt oder per import einbindet,
    das sind lediglich abkürzungen für die Entwickler!

#   Sichtbarkeit
-   Public, ist für alle sichtbar.
-   Private, nicht sichtbar
-   Protected, ist Geschützt
-   Packet Public = bedeutet bsp.weise das alles innerhalb des packets öffentlich sind,
    aber für Typen außerhalb des Packets unsichtbar.

#   Eigenschaften
-   Statische Eigenschaften sind kursiv gesetzt. bsp. Math.random();

#   Arrays
-   Wenn man Arrays aufgebaut hat, bleiben sie fest, man kann sie nachträglich nicht mehr ändern.
-   Die Array-Initialisierung ist eine angenehme, kompakte schreibweise, das wir variablen deklarieren und gleichzeitig
    mit einem wert initialisieren können.
    Hinter dieser Array-Initialisierung stecken zwei Operationen.
    Zunächst wird ein Array angelegt mit der richtigen größe und anschließend werden die entsprechenden Zellen, mit entsprechenden Werten belegt

#   Compiler
-   Der Compiler generiert Bytecode und der Bytecode initialisiert jedes Element.
-   Deswegen hat jede Variable entsprechend UNI-Code ihre Byte größe, mit der sie initialisiert wird und zwischengespeichert wird.
    Bsp. short 4 byte oder long 8 byte pro string

#   Var-args
-   Für den Compiler sind Var-args, nicht anderes als Arrays.
-   Performance consequence, wenn man sehr intensiv mit varargs arbeitet, dann führt das immer dazu,
    dass temporäre Array objekte aufgebaut werden, Abgerufen und gelöscht!
    In einer endlosschleife würde das massiven druck auf den Garbage Collector ausüben.
    Deswegen versucht man möglichst auf varargs in schleifen zu verzichten, damit es nicht zu performance einbussen kommt